---
title: "Stats 306: Lab 9"
author: "Your Name"
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

## Set up

```{r installPackages, echo=FALSE, include=FALSE, message=FALSE}
# This just checks if students need to install some packages that they might 
# not have.
if (!require(nycflights13)) install.packages("nycflights13", repos = "http://cran.us.r-project.org")
if (!packageVersion("learnr") == "0.11.1") install.packages("learnr", repos = "http://cran.us.r-project.org")
```

```{r setup, eval=TRUE, include=FALSE, message=FALSE, echo=FALSE}
library(learnr)     # For interactive exercises
library(lubridate)
library(tidyverse)  # For ggplot2, dplyr, readr
library(nycflights13)

tutorial_options(exercise.reveal_solution=T)
```

```{r fake_setup, echo=TRUE, eval=FALSE}
library(learnr)     # For interactive exercises
library(lubridate)
library(tidyverse)  # For ggplot2, dplyr, readr
library(nycflights13)
```


## Today's Content

- Strings
- Data Imports
- Dates



## Strings and Regular Expressions

### Strings

Recall that a string is character data enclosed in double `"` or single `'` quotes. In R, strings exist in character vectors.
```{r}
words[1:5]
```

The `stringr` package contains many useful functions for working with strings. In lecture, we went over some commonly used `stringr` functions.

`str_c()` is used to concatenate strings. These strings can be given in separate vectors, in which case the `sep` argument should be used to control what goes between consecutive strings.
```{r}
str_c("lions", "tigers", "bears", "oh my!", sep = ", ")
```

`str_c()` can also be given a single vector of strings. In this case, the `collapse` argument should be used to control what goes between consecutive strings.
```{r}
parts <- c("lions", "tigers", "bears", "oh my!")
str_c(parts, collapse = ", ")
```

`str_length()` essentially returns the number of characters in a string.
```{r}
str_length("My favorite colors are maize and blue.")
```

`str_sub()` extracts a substring of a string. `start` and `end` are the indices of the starting and ending characters of the substring.
```{r}
str_sub("November", start = 3, end = 6)
```

`str_split()` splits a string into substrings given a separator. Note that it returns a list.
```{r}
str_split("lions, tigers, bears, oh my!", pattern = ", ")
```

**Exercise:** Using the vector `base::LETTERS`, make a vector with 25 strings in which the first string is `"A precedes B"`, the second string is `"B precedes C"`, etc.

```{r str_c, exercise=TRUE}

```

```{r str_c-hint}
# Note that LETTERS[-1] contains B through Z
LETTERS[-1]
```

```{r str_c-solution}
str_c(LETTERS[-26], "precedes", LETTERS[-1], sep = " ")
```



### Regular Expressions

A *regular expression* is a string specifying a pattern that other strings may or may not match. Regular expressions can be used to

  - find strings matching a pattern
  - modify substrings matching a pattern
  - delete substrings matching a pattern

**Exercise:** Write a regex that matches `"this"` and `"the"` but not `"third"`. Use it to extract all instances of the two words from the paragraph below, which is stored in `baseball`.

```
According to Baseball Reference’s wins above average, The Red Sox had the best 
outfield in baseball— one-tenth of a win ahead of the Milwaukee Brewers, 11.5 to 11.4. And 
that’s despite, I’d argue, the two best position players in the NL this year (Christian 
Yelich and Lorenzo Cain) being Brewers outfielders. More importantly, the distance from 
Boston and Milwaukee to the third-place Yankees is about five wins. Two-thirds of the Los 
Angeles Angels’ outfield is Mike Trout (the best player in baseball) and Justin Upton (a 
four-time All-Star who hit 30 home runs and posted a 122 OPS+ and .348 wOba this year), 
and in order to get to 11.5 WAA, the Angels’ outfield would have had to replace right 
fielder Kole Calhoun with one of the three best outfielders in baseball this year by WAA.
```

```{r regex-setup, include=TRUE}
baseball <- "According to Baseball Reference’s wins above average, The Red Sox had the best 
outfield in baseball— one-tenth of a win ahead of the Milwaukee Brewers, 11.5 to 11.4. And 
that’s despite, I’d argue, the two best position players in the NL this year (Christian 
Yelich and Lorenzo Cain) being Brewers outfielders. More importantly, the distance from 
Boston and Milwaukee to the third-place Yankees is about five wins. Two-thirds of the Los 
Angeles Angels’ outfield is Mike Trout (the best player in baseball) and Justin Upton (a 
four-time All-Star who hit 30 home runs and posted a 122 OPS+ and .348 wOba this year), 
and in order to get to 11.5 WAA, the Angels’ outfield would have had to replace right 
fielder Kole Calhoun with one of the three best outfielders in baseball this year by WAA."
```

```{r regex, exercise=TRUE, exercise.setup="regex-setup"}

```

```{r regex-hint}
str_extract_all(...)
```

```{r regex-solution}
str_extract_all(baseball, "th(e|is)")
str_extract_all(baseball, "(t|T)h(e|is)") # including capitalized T
```



    
## Data Imports
- We have previously discussed that data may be available to us for analysis in two major forms: creating them ourselves and importing them from other sources.   
- The major sources of data for importation are summarized in the figure below.

<center>

![Types of Data Imports](images/data_imports.png){width=100%}

</center>

- For the purpose of this class, we narrowed our focus on flat files from the `readr` package.
- Specifically, we have explored using some functions as:
  + `read_csv` - for comma separated values
  + `read_tsv` - for tab separated values
  + `read_delim` - for general delimiters (could be comma, semi-colon, tab, pipe or any delimiter)
  
- Let us answer the following questions based on what we have learned about these functions.

### Question 1 {.tabset}

#### Question 
What function would you use to read a file where fields were separated with
"|"?

#### Answer

Use the `read_delim()` function with the argument `delim="|"`
```
Use the read_delim() function with the argument delim="|"
```



### Question 2 {.tabset}

#### Question 
Apart from `file`, `skip`, and `comment`, what other arguments do `read_csv()` and `read_tsv()` have in common?

#### Answer
They have the following arguments in common:
```{r DIQ2, exercise = TRUE}
intersect(names(formals(read_csv)), names(formals(read_tsv)))
```



### Question 3 {.tabset}

#### Question 
Sometimes strings in a CSV file contain commas. To prevent them from causing problems they need to be surrounded by a quoting character, like `"` or `'`. By default, `read_csv()` assumes that the quoting character will be `"`. What argument do you need to specify to read the following text into a data frame using `read_delim()`?

```
"x,y\n1,'a,b'"
```


#### Answer
For `read_delim()`, we will will need to specify a delimiter, in this case `","`, and a `quote` argument.

```{r DIQ3, exercise = TRUE}
x <- "x,y\n1,'a,b'"
read_delim(x, ",", quote = "'")
```



### Question 4 {.tabset}

#### Question 
Identify what is wrong with each of the following inline CSV files. What happens when you run the code?

```
read_csv("a,b\n1,2,3\n4,5,6")
read_csv("a,b,c\n1,2\n1,2,3,4")
read_csv("a,b\n1,2\na,b")
read_csv("a;b\n1;3")
```

#### Answer
1. Only two columns are specified in the header “a” and “b”, but the rows have three columns, so the last column is dropped.
```{r DIQ4a}
read_csv("a,b\n1,2,3\n4,5,6")
```

2. The numbers of columns in the data do not match the number of columns in the header (three). In row one, there are only two values, so column `c` is set to missing. In row two, there is an extra value, and that value is dropped.
```{r DIQ4b}
read_csv("a,b,c\n1,2\n1,2,3,4")
```

3. Both “a” and “b” are treated as character vectors since they contain non-numeric strings. This may have been intentional, or the author may have intended the values of the columns to be “1,2” and “a,b”.
```{r DIQ4c}
read_csv("a,b\n1,2\na,b")
```

4. The values are separated by “;” rather than “,”. Use read_csv2() instead:
```{r DIQ4d}
read_csv("a;b\n1;3")

read_csv2("a;b\n1;3")
```




## Dates 

Dates are a common and tricky data type that we need to deal with often. Here are some things that we need to consider when working with dates: 

- Time intervals between dates are not always constant! For example, if I add 365 days to `2016-01-01`, I get `2016-12-31`!:

```{r}
as.Date("2016-01-01") + lubridate::days(365)
```

- Dates and times can usually be considered as continuous data types, but they are usually stored in files as strings or characters. 

- There is no standard way to store Dates and times. For example: `"2012-03-21"` vs `"03/21/12"`. 

**Exercise:** Convert the following strings into date objects. 

```{r convertDates, exercise=TRUE}
d1 <- "Jan 01, 2019"
d2 <- "11-28-95"
d3 <- "Nov 7, 7:49 PM"
```

```{r convertDates-hint}
# There were several functions that we used to "parse" dates:

# lubridate::ymd
# lubridate::mdy
# lubridate::ydm_hms
# readr::parse_date
# readr::parse_datetime
# and more! 

# Which do you think will be useful? 
```

```{r convertDates-solution}
d1 <- "Jan 01, 2019"
d2 <- "11-28-95"
d3 <- "November 07, '04, 10:04 PM"

# One possbile solution
readr::parse_date(d1, format = "%b %d, %Y")
lubridate::mdy(d2)
readr::parse_datetime(d3, "%B %d, '%y, %H:%M %p")
```



